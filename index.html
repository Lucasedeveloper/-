<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>üéÅ</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: black;
      overflow: hidden;
    }
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 0;
    }
  </style>
</head>
<body>
<canvas id="glCanvas"></canvas>
<canvas id="textCanvas"></canvas>

<script type="x-shader/x-fragment" id="fragShader">
precision mediump float;

uniform float time;
uniform vec2 resolution;

float heart(vec2 p) {
    p *= 1.8;
    p.y = p.y + 0.25;
    float x = p.x;
    float y = p.y;
    float d = x * x + pow(y - sqrt(abs(x)), 2.0) - 0.6;
    return d;
}

void main() {
    vec2 uv = (gl_FragCoord.xy - resolution.xy * 0.5) / resolution.y;
    float d = heart(uv * 1.8);
    float pulse = 0.2 * sin(time * 2.0) + 0.1 * cos(time * 3.0);
    float fill = smoothstep(0.0, 0.2, abs(d) + pulse);
    float intensity = 0.04 / (abs(d) + 0.005 + pulse * 0.5);
    float colorSwitch = sin(time * 2.0);
    vec3 redColor = vec3(1.0, 0.1, 0.3);
    vec3 greenColor = vec3(0.0, 1.0, 0.2);
    vec3 color = mix(redColor, greenColor, smoothstep(-1.0, 1.0, colorSwitch)) * intensity;
    float glow = 0.01 / (abs(d) + 0.01) * (1.0 - fill);
    color += glow * mix(redColor, greenColor, smoothstep(-1.0, 1.0, colorSwitch));
    gl_FragColor = vec4(color, 1.0 - fill * 0.3);
}
</script>

<script>
  const glCanvas = document.getElementById('glCanvas');
  const textCanvas = document.getElementById('textCanvas');
  const gl = glCanvas.getContext('webgl');

  let width, height;

  function resize() {
    width = glCanvas.width = textCanvas.width = window.innerWidth;
    height = glCanvas.height = textCanvas.height = window.innerHeight;
    gl.viewport(0, 0, width, height);
  }
  window.addEventListener("resize", resize);
  resize();

  const vertShaderSrc = `
    attribute vec2 position;
    void main() {
      gl_Position = vec4(position, 0, 1);
    }
  `;

  const fragShaderSrc = document.getElementById("fragShader").textContent;

  function compileShader(src, type) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, src);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      throw new Error(gl.getShaderInfoLog(shader));
    }
    return shader;
  }

  const vertShader = compileShader(vertShaderSrc, gl.VERTEX_SHADER);
  const fragShader = compileShader(fragShaderSrc, gl.FRAGMENT_SHADER);

  const program = gl.createProgram();
  gl.attachShader(program, vertShader);
  gl.attachShader(program, fragShader);
  gl.linkProgram(program);
  gl.useProgram(program);

  const position = gl.getAttribLocation(program, 'position');
  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1, -1,
    1, -1,
    -1, 1,
    -1, 1,
    1, -1,
    1, 1
  ]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(position);
  gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

  const uTime = gl.getUniformLocation(program, 'time');
  const uResolution = gl.getUniformLocation(program, 'resolution');

  const ctx = textCanvas.getContext('2d');

  function drawHeartPath(ctx) {
    ctx.save();
    ctx.translate(width / 2, height / 2);
    ctx.scale(height * 0.5, height * 0.5); // Scale to match WebGL coordinates
    ctx.beginPath();
    
    const numPoints = 100;
    for (let i = 0; i <= numPoints; i++) {
      const t = (i / numPoints) * 2 * Math.PI;
      const x = 16 * Math.pow(Math.sin(t), 3) / 18;
      let y = (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) / 18;
      y = -y - 0.25; // Adjust to match the heart function in the shader
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    ctx.closePath();
    ctx.restore();
  }

  function drawText() {
    ctx.clearRect(0, 0, textCanvas.width, textCanvas.height);
    
    // Save the context state and apply the heart clipping region
    ctx.save();
    drawHeartPath(ctx);
    ctx.clip();

    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    const lines = [
      "Imagina se voc√™ soubesse o quanto eu penso em voc√™ nos momentos mais aleat√≥rios do dia.",
      "N√£o √© exagero, √© s√≥ aquele sentimento tranquilo que vai ficando cada vez mais certo.",
      "Gosto de voc√™ do jeito que √©, sem filtro, sem pose, s√≥ sendo voc√™ mesmo.",
      "Realmente fico feliz s√≥ de ver seu nome aparecer na tela.",
      "Eu tento agir normal, mas a verdade √© que voc√™ tem um efeito diferente em mim.",
      "De um jeito calmo e sincero, voc√™ acabou se tornando algu√©m muito especial pra mim.",
      " ‚ô•"
    ];

    const capitalColors = [
      "rgb(255, 0, 0)", "rgb(255, 165, 0)", "rgb(255, 255, 0)",
      "rgb(128, 0, 128)", "rgb(0, 191, 255)", "rgb(255, 20, 147)"
    ];

    const defaultColor = "rgba(255, 255, 255, 1.0)";
    let colorIndex = 0;

    // Dynamically calculate starting y to center text within heart height
    const heartHeight = height * 0.6;
    const totalLineHeight = (lines.length - 1) * 40 + 52;
    let y = height / 2 - totalLineHeight / 2 ;

    ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
    ctx.shadowBlur = 6;
    ctx.shadowOffsetY = 2;

    lines.forEach((line, index) => {
      const fontSize = index === lines.length - 1 ? 52 : 34 - index * 0.5;
      ctx.font = `bold ${fontSize}px sans-serif`;
      y += index === 0 ? 0 : 40;

      let currentX = width / 2;
      const words = line.split(" ");
      let wordX = currentX - ctx.measureText(line).width / 2;

      words.forEach((word, wordIndex) => {
        for (let i = 0; i < word.length; i++) {
          const char = word[i];
          ctx.fillStyle = /[A-Z]/.test(char) ? capitalColors[colorIndex % capitalColors.length] : defaultColor;
          if (/[A-Z]/.test(char)) colorIndex++;
          ctx.fillText(char, wordX, y);
          wordX += ctx.measureText(char).width + 5;
        }
        if (wordIndex < words.length - 1) {
          wordX += 20;
        }
      });
    });

    ctx.shadowBlur = 0;
    ctx.restore(); // Restore the context to remove the clipping region
  }

  let time = 0;
  function render() {
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.uniform1f(uTime, time);
    gl.uniform2f(uResolution, width, height);
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    drawText();
    time += 0.01;
    requestAnimationFrame(render);
  }

  render();
</script>
</body>
</html>